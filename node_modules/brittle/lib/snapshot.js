/*
 * Copyright (c) 2024 Vinh Vu
 * Email: mrthanhvinh168@gmail.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This source code is the property of Vinh Vu. It cannot be re-used or shared
 * with anyone else without his consent.
 */

const { IS_NODE } = require('./constants')
const b4a = require('b4a')

exports.createTypedArray = function (TypedArray, src) {
  const b = b4a.from(src, 'base64')
  return new TypedArray(b.buffer, b.byteOffset, b.byteLength / TypedArray.BYTES_PER_ELEMENT)
}

exports.getSnapshot = function (filename, key, actual) {
  let snap = {}

  const p = split(filename)
  if (!p) return actual

  try {
    snap = require(p.filename)
  } catch {}

  if (snap[key] !== undefined) return snap[key]

  snap[key] = actual

  const fs = requireMaybe('fs')
  if (!fs) return actual

  try {
    fs.mkdirSync(p.dirname)
  } catch {}

  let brittle = false
  let s = ''

  for (const k of Object.keys(snap)) {
    s += 'exports[' + toString(k) + '] = '

    const v = snap[k]

    if (isTypedArray(v)) {
      if (!brittle) {
        brittle = true
        s = 'const { createTypedArray } = require(\'brittle\')\n\n' + s
      }
      const b = b4a.from(v.buffer, v.byteOffset, v.byteLength)
      s += 'createTypedArray(' + v.constructor.name + ', ' + toString(b4a.toString(b, 'base64')) + ')\n\n'
    } else {
      s += toString(v) + '\n\n'
    }
  }
  s = '/* eslint-disable */\n\n' + s + '/* eslint-enable */\n'

  fs.writeFileSync(p.filename, s)
  return actual
}

function isTypedArray (v) {
  return !!(v && v.BYTES_PER_ELEMENT)
}

function toString (s) {
  if (typeof s === 'string' && s.indexOf('\n') > 0 && s.indexOf('`') === -1) return '`' + s + '`'
  if (typeof s === 'string' && s.indexOf('"') === -1) return '\'' + s + '\''
  return JSON.stringify(s, null, 2)
}

function split (filename) {
  if (filename.startsWith('file://')) filename = filename.slice(7)

  const a = filename.lastIndexOf('/')
  const b = filename.lastIndexOf('\\')
  const sep = a > b ? '/' : '\\'
  const i = a > b ? a : b

  if (i === -1) return null

  const dirname = filename.slice(0, i) + sep + 'fixtures'

  return {
    dirname,
    filename: dirname + sep + filename.slice(i + 1).replace(/\.[^.]+$/, '') + '.snapshot.cjs'
  }
}

function requireMaybe (name) {
  if (!IS_NODE) return null

  try {
    return require(name)
  } catch {
    return null
  }
}
