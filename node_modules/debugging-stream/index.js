/*
 * Copyright (c) 2024 Vinh Vu
 * Email: mrthanhvinh168@gmail.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This source code is the property of Vinh Vu. It cannot be re-used or shared
 * with anyone else without his consent.
 */

const { Duplex } = require('streamx')

module.exports = class DebuggingStream extends Duplex {
  constructor (stream, { random = Math.random, latency = 0 } = {}) {
    super()

    this._random = random
    this._latency = toRange(latency)

    this._queued = []
    this._ondrain = null

    this.stream = stream

    let ended = false

    this.stream.on('data', (data) => {
      this._queue({ pending: true, data, error: null, done: false })
    })
    this.stream.on('end', () => {
      ended = true
      this._queue({ pending: true, data: null, error: null, done: false })
    })
    this.stream.on('error', (err) => {
      this._queue({ pending: true, data: null, error: err, done: true })
    })
    this.stream.on('close', () => {
      if (ended) return
      this._queue({ pending: true, data: null, error: null, done: true })
    })
    this.stream.on('drain', () => {
      this._triggerDrain()
    })
  }

  _triggerDrain () {
    if (this._ondrain === null) return
    const ondrain = this._ondrain
    this._ondrain = null
    ondrain()
  }

  _queue (evt) {
    const l = this._latency.start + Math.round(this._random() * this._latency.variance)

    this._queued.push(evt)

    setTimeout(() => {
      evt.pending = false
      this._drain()
    }, l)
  }

  _drain () {
    let paused = false
    while (this._queued.length > 0 && this._queued[0].pending === false) {
      const q = this._queued.shift()

      if (q.done) {
        this.destroy(q.error)
        continue
      }

      if (this.push(q.data) === false) {
        paused = true
      }
    }

    if (paused) this.stream.pause()
  }

  _read (cb) {
    this.stream.resume()
    cb(null)
  }

  _predestroy () {
    this._triggerDrain()
  }

  _write (data, cb) {
    if (this.stream.write(data) === false) {
      this._ondrain = cb
      return
    }
    cb(null)
  }

  _final (cb) {
    this.stream.end()
    cb()
  }
}

function toRange (range) {
  if (typeof range === 'number') {
    range = [range, range]
  }

  return { start: range[0], variance: range[1] - range[0] }
}
